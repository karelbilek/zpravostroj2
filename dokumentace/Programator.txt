uložení článků
---------------

Články jsou uloženy ve složce data/articles, v souboru na adrese data/articles/Y/M/D/N.bz2, kde Y je rok, M je měsíc, D je den a N je číslo článku. Jsou serializovány pomocí YAML::XS a MooseX::Storage, a jsou zazipovány programem bzip2.

Postup zpracovávání článků
-------------------

(Podrobnější popisy jednotlivých kroků jsou v příslušných modulech jako komentáře a dle mého je redundantní je zde znovu přepisovat.)

O stahování nových článků se "stará" modul Zpravostroj::Updater.

Nejprve je jím spuštěn Zpravostroj::TectoServer, což je separátní fork (více o forcích dále), ve kterém běží TectoMT.

Potom jsou staženy adresy článků pomocí modulu Zpravostroj::RSS (adresy RSS kanálů a adresy stažených článků jsou v adresáři data/articles/RSS). Poté je článek stáhnut pomocí modulu Zpravostroj::WebReader, poté se pomocí Zpravostroj::Readability z HTML zdroje získá samotný článek bez okolních textů. Poté se modul Zpravostroj::TectoClient spojí s TectoServerem a pošle mu slova ve článku; TectoServer tato zlemmatizuje a určí pojmenované entity.

Tato "kaskáda" operací se spouští díky Moose konstruktoru v modulu Zpravostroj::Article.

Články jsou poté uloženy pomocí subrutiny Zpravostroj::Globals::dump_bz2.

Forker
------
Při experimentování jsem zjistil, že pro rychlejší a spolehlivější uvolňování paměti po operacích náročných na paměť, jako je například načítání článků, je lepší použít modul forks, pomocí něho vytvořit nový proces, náročnější operaci udělat v separátním procesu a výsledky nasdílet zpátky. Program tak uvolní paměť ihned po skončení procesu. (Tento fakt jsem si posléze ověřil i na jiném, nesouvisejícím projektu.)

Modul forks funguje jako "náhrada" vestavěných perl threadů, které ale nejsou příliš praktické. forks používá naprosto stejný syntax, jako modul threads, včetně sdílení proměnných pomocí shared (pro sdílení dat si modul forks vytvoří "nadřazený" proces a např. zámky implementuje pomocí socketů).

Kromě toho jsem zjistil, že při načítání většího množství článků je "bottleneck" rozbalování z bz2 a deserializace; je ale možné načítání článků mírně paralelizovat tak, že např. při rozbalování jednoho článku může systém zároveň dělat něco jiného, tím i případně využít více jader procesoru, čímž se vše zrychlí.

Pro tuto paralelizaci ale není možné, aby běželo příliš mnoho procesů najednou. Proto jsem si vytvořil objekt Zpravostroj::Forker, který za mě hlídá postupné spouštění forků.

Funguje tak, že se mu dávají odkazy na subroutiny pomocí $forker->run($subroutine), tyto si pamatuje v poli jako ve frontě. Z fronty potom postupně subroutiny spouští v separátních forcích tak, aby nebylo zároveň spuštěno víc forků, než má Forker povoleno. Počet povolených forků je Forkeru zadáno při konstrukci.

Forker ale nemá, jak by sám tyto forky spouštěl "mimo" běh hlavního programu (není možné určit vlastní fork na spouštění forků, protože odkazy na subroutiny není možno sdílet mezi jednotlivými forky). Proto je nutné po zadání všech subroutin pomocí $forker->run() buď pravidelně spouštět $forker->check_waiting(), který jednou zkotroluje počet běžících forků a případně nějaké další spustí, nebo jednou spustit $forker->wait(), což je funkce, která počká na doběhnutí všech nedoběhnutých forků (která pravidelně spouští $forker->check_waiting). Pokud se jakékoliv výsledky vrací zpátky do nějaké proměnné, která existuje mimo subroutinu, tak tato musí být sdílená přes modul forks::shared, jinak se při zapisování (perlí fork funguje na principu copy-on-write) vytvoří *kopie* této proměnné.

Forkery mohou být "vnořené" do sebe - tj. v subroutině, kterou dostane a bude spouštět jeden Forker může být zase jiný Forker. Forkery ale není možno sdílet mezi forky, tj. "vnitřní" Forker musí být v subroutině vytvořen a v ní opět zaniknout. Je také nutné

Traversable
-----------
Zpravostroj::Traversable je zobecnění objektu, který má více podobjektů, které lze postupně načítat a na kterých lze něco postupně spouštět (traverzovat). V mém případě jsou to dva objekty - jednak objekt Zpravostroj::AllDates, který představuje všechny dny (a který nemá žádné vlastnosti, tj. všechny jeho instance jsou jakoby datově shodné), a objekt Zpravostroj::DateArticles, který představuje všechny články daného dne. V případě Zpravostroj::AllDates jsou "podřazené" objekty, přes které se "traverzuje", objekty Zpravostroj::DateArticles, objektům Zpravostroj::DateArticles jsou zase "podřazené" objekty Zpravostroj::Article.

Zpravostroj::Traversable je abstraktní třída (v řeči Moose "role"), která funguje tak, že všechny podřazené objekty zároveň nikdy nejsou v paměti (protože by se všechny články naráz do paměti nevešly), ale jednak má abstraktní metodu _get_traversed_array, která vrátí pole řetězců, které jakoby představují podřazené objekty, a abstraktní metodu _get_object_from_string, která objekt z řetězce vyrobí. 

Poté má (neabstraktní) metodu traverse($sub, $count), která dostane odkaz na subroutinu, kterou postupně spouští na každý podřazený objekt. Načtení podobjektu a samotné spuštění subroutiny proběhne v separátním forku, spouštěného pomocí modulu Zpravostroj::Forker (viz výše), forků je zároven povolenu spouštět $count. Pokud je $count 0 nebo 1, žádné forkování neprobíhá a subroutiny se spouštějí všechny ve stejném procesu. (Nemůžu zde napsat "v hlavním procesu", protože zatímco traverzování přes AllDates může forkovat, traverzování přes DateArticles nemusí; naopak, stejně jako můžou být Forkery "vnořovány" do sebe, tak může být traverzování vnořováno do sebe).

Opět, jelikož jsou subroutiny spouštěny přes Forker, pokud jsou nějaké výsledky vraceny ven ze subroutiny do nějaké proměnné, je nutné tuto proměnou sdílet mezi forky pomocí forks::shared.

Kromě toho má Zpravostroj::Traversable abstraktní metodu _after_traverse, která vždy proběhne na každém podobjektu po spuštění $sub. Tato metoda dostane jako parametry to, co vrací $sub. Používám to pouze pro ukládání článků po případné změně - návratová hodnota mi potom říká, jestli se článek změnil, nebo nezměnil.

Tf-Idf témata
-------------
Pro TF-IDF témata je nejprve nutné znát IDF vektor (podrobněji viz bakalářská práce); tento lze načíst pomocí modulu Zpravostroj::InverseDocumentFrequencies, který si vektor ukládá v adresáři data/idf.

Pokud IDF vektor není znám, je možné jej také spočítat pomocí Zpravostroj::InverseDocumentFrequencies; pokud už spočítaný je, ale přibydou nové články, není nutné jej celý přepočítávat - modul Zpravostroj::InverseDocumentFrequencies si pamatuje poslední článek, který byl započítán, a přidá všechny novější.

Pokud by bylo potřeba opravdu přepočítat celý IDF vektor znovu, je nutné smazat celý adresář data/idf/.

Pokud chci článku vypočítat TF-IDF témata, je třeba článek načíst, spustit na něj count_tf_idf_themes a znovu ho uložit; toto dělá Zpravostroj::AllDates::get_statistics_tf_idf_themes (o metodách get_statistics_ píšu více v uživatelské části dokumentace).



OutCounter
----------

V projektu často potřebuji sečíst velké množství dat, které jsou ve formátu klíč-hodnota (například pro IDF potřebuji zjistit pro jednotlivá slova počet dokumentů, ve kterých se vyskytují). Pro menší množství dat lze použít velký perl hash, do kterého se postupně přičítá; pro větší množství dat se nemusí tento hash vejít do paměti, nebo v případě, že používám metodu forkování, popsanou výše, trvá dlouho sdílení hashů mezi thready a je nutno je nějak zamykat.

Místo toho lze ale využít vnějšího třídění pomocí unixovského příkazu sort. Všechny dvojice klíč-hodnota postupně vypisuji do souboru, poté seřadím podle klíče a poté jedním průchodem sečtu a rovnou vypisuji sečtené hodnoty. Pokud potřebuji ještě naopak seřadit vše podle hodnot (např. pro nejčastější témata některého typu), znovu použiji příkaz sort.

Jak píšu v uživatelské části, používám k sortu option +, který je v GNU verzi, ale nemusí být v jiných verzích (např. mám pocit, že není na systému Mac OS X).

Všechny výše popsané úkony dělám pomocí objektu Zpravostroj::OutCounter, kterému při vytvoření řeknu cestu k souboru, kam má zapisovat, a binární příznak, jestli má při už existující soubor smazat, nebo ne. Podrobněji je postup popsán v komentářích tohoto modulu.

Evaluace kategorizace
------------
Evaluaci různého druhu kategorizací provádím pomocí Zpravostroj::Categorizer::Categorizer, což je abstraktní kategorizér, a Zpravostroj::Categorizer::Evaluator, který na 200 vybraných článcích Zpravostroj::Categorizer::Categorizer otestuje a srovná jeho zatřizování s ručně zatřízenými články.

Tuto evaluaci popisuji poměrně podrobně v bakalářské práci.


Objektový model
---------------

Všechny moduly, co jsou zároveň objekty, jsou objekty skrze objektový systém Moose.

Objekty jsou v projektu tyto:

- Zpravostroj::Word reprezentuje slovo, u kterého může být případně skóre.
- Zpravostroj::Article reprezentuje článek.
- Zpravostroj::DateArticles reprezentuje všechny články jednoho dne.
- Zpravostroj::Date reprezentuje datum. Tento modul by mohl být shodný s modulem DateArticles, protože jednotlivé DateArticles se odlišují pouze podle Date a naopak každému Date lze jednoduše vytvořit DateArticles; rozdělené do dvou modulů je to jednoduše proto, že jeden modul má "na starosti" věci, týkající se opravdu pouze dat (tj. předcházející den, následující den, načtení datumu ze stringu apod.), druhý má naopak "na starosti" články v daném dni
- Zpravostroj::AllDates reprezentuje všechny dny. Tento modul je objektem pouze proto, aby mohl mít roli Zpravostroj::Traversable.
- Zpravostroj::Traversable, Zpravostroj::Forker a Zpravostroj::OutCounter jsem již popsal výše
- Zpravostroj::Categorizer::Categorizer a Zpravostroj::Categorizer::Evaluator jsem velmi stručně popsal též výše
- Zpravostroj::Categorizer::TotallyRetarded je triviální kategorizér
- Zpravostroj::Categorizer::FreqThemes, Zpravostroj::Categorizer::StopThemes a Zpravostroj::Categorizer::TfIdfThemes dávají do kategorií podle témat, hledaných pouze z článku samého
- Zpravostroj::Categorizer::AICategorizer je učící se kategorizér, který je třeba nejdříve naučit na už určených kategoriích. Používá CPAN modul AI::Categorizer.

